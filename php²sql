<?php

/**
 * x²sql
 *
 * An open source SQL-generator-class.
 * Inspired by the database-driver in Code-igniter http://ellislab.com/codeigniter.
 *   if (get_magic_quotes_gpc()) {        $value = stripslashes($value);    }
 * @package		x²sql
 * @author		mborchert
 * @copyright           Copyright (c) 2013.
 * @license		http://creativecommons.org/licenses/by/3.0/deed.de
 * @link		http://get-resource.net/app/php/x²sql
 * @since		Version 1.0
 * @todo: join
 * @todo: support special settings : distinct, etc.
 * @todo: config_setting_options for complode : delimiter,no_brackets,no_alias,cast,escape,allow,array_position
 */
class x²sql {

	const tokenizer = ":";
	const placerholder = "?";
	const esc_string = "'";
	const esc_key = "`";
	const esc_non = "";
	const esc_num = "";
	const null_string = "null";
	const regex_operators = "/^(:=|\|\||OR|XOR|&&|AND|NOT|BETWEEN|CASE|WHEN|THEN|ELSE|=|<=>|>=|<=|<|<>|>|!=|IS|LIKE|REGEXP|IN|\||&|<<|>>|-|\+|\*|\/|DIV|%|MOD|^|~|!|BINARY|COLLATE)$/i";
	const x²sql = "x²sql";
	const x²null = "x²null";
	const x²bool = "x²bool";
	const x²number = "x²number";
	const x²string = "x²string";
	const x²func = "x²func";
	const x²token = "x²token";
	const x²place = "x²place";
	const x²key = "x²key";
	const x²order = "x²order";
	const x²operator = "x²operator";
	const x²math = "x²math";
	const char_list_delimiter = ",";
	const char_bracket_open = "(";
	const char_bracket_close = ")";

	private $flag;
	public $__name;
	public $comment;
	public $command;
	public $command_type;
	public $prepare = false;
	public $bind;
	public $bind_count = 0;
	public $fetch = "fetchAll";
	public $fetch_type = PDO::FETCH_NUM;
	public $init_data;
	public $last_append;
	public $current_call;
	public $disallow_create = [];

	const token_function_list = ",command,select,from,union,where,group,having,order,limit,offset,fetch,fetch_type,alias,insert,columns,values,update,delete,where,transaction,set,__name,comment,create,options,name,plock,";

	public function __toString() {
		return (is_array($this->command)) ? implode("\n", $this->command) : $this->command;
	}

	public function reset() {
		$this->bind = new stdClass();
		$this->bind_count = 0;
		$this->prepare = false;
		$this->init_data = null;
		$this->command = "";
		$this->command_type = null;
		$this->last_append = "";
		$this->fetch = "fetchAll";
		$this->fetch_type = PDO::FETCH_NUM;
		$this->comment = "";
		$this->__name = "";
	}

	public function get_cfg_data(&$cfg) {
		if (is_string($cfg) && preg_match("/^[\{\(]{1,999}/", $cfg)) {
			$jcfg = json_decode($cfg);
			if (!is_array($jcfg) && !is_object($jcfg)) {
				throw new Exception("invalid Json");
			}
			return $jcfg;
		}
		return $cfg;
	}

	public function Sql(&$cfg) {
		$this->init_data = $cfg;
		$cfg = $this->get_cfg_data($cfg);
		if (isset($cfg->command)) {
			if(is_string($cfg->command)){
				$_ = explode(" ",$cfg->command);
				$this->command_type =  array_shift($_);
			}else{
			$this->command_type = $cfg->command[0];
			foreach($cfg->command as &$c){
				if(is_object($c) || is_array($c)) $c = $this->complode($c);
			}
			$this->command = implode(" ",$cfg->command);
			}
			return $this;
		}
		if (isset($cfg->select))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->select($cfg->select)
											->from(@$cfg->from)
											->union(@$cfg->union)
											->where(@$cfg->where)
											->group(@$cfg->group)
											->having(@$cfg->having)
											->order(@$cfg->order)
											->limit(@$cfg->limit)
											->offset(@$cfg->offset)
											->fetch(@$cfg->fetch)
											->fetch_type(@$cfg->fetch_type)
											->alias(@$cfg->alias,$cfg);
		if (isset($cfg->insert))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->insert($cfg->insert)
											->columns($cfg->columns)
											->values($cfg->values);
		if (isset($cfg->update))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->update($cfg->update)
											->set($cfg->set)
											->where($cfg->where);
		if (isset($cfg->delete))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->delete($cfg->delete)
											->where($cfg->where);
		if (isset($cfg->transaction))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->transaction($cfg->transaction);
		if (isset($cfg->set))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->flag("command")
											->set($cfg->set)
											->unflag();
		if (isset($cfg->create))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->create($cfg->create)
											->options(@$cfg->options)
											->name($cfg->name)
											->plock($cfg);
	}

	public function __construct($cfg = null) {
		$this->bind = new stdClass;

		if ($cfg) {
			return $this->Sql($cfg);
		}
	}

	public function flag($hint) {
		$this->flag = $hint;
		return $this;
	}

	public function unflag() {
		$this->flag = null;
		return $this;
	}

	static function query($cfg = null) {
		return new x²sql($cfg);
	}

	public function complode($set, $cfg = null) {
		if (!$cfg)
			$cfg = new stdClass;
		if ($set === null) {
			return $this->complode(new x²null(), $cfg);
		}
		if (is_array($set)) {
			$delimiter = @$cfg->delimiter ? $cfg->delimiter : x²sql::char_list_delimiter;
			foreach ($set as $key => $subset) {
				$cfg->array_position = $key;
				$_[] = $this->complode($subset, $cfg);
			}
			return ((@$cfg->no_brackets) ? "" : x²sql::char_bracket_open)
							. implode($delimiter, $_)
							. ((@$cfg->no_brackets) ? "" : x²sql::char_bracket_close);
		} elseif (is_object($set)) {
			$class = get_class($set);
			if (isset($cfg->allow) && !in_array($class, $cfg->allow) && !method_exists($class, "__toString")) {
				if ($class != "stdClass")
					throw new Exception("$class is not allowed");
			}
			switch ($class) {
				case self::x²place :
					$this->prepare = true;
					$counter = $this->bind_count++;
					$this->bind->$counter = new stdClass();
					$this->bind->$counter->bind = "Param";
					$this->bind->$counter->key = self::placerholder;
					$this->bind->$counter->type = PDO::PARAM_STR;
					$this->bind->$counter->value = self::null_string;
					if (@$cfg->no_alias) {
						return x²sql::escape($set->value, "");
					}
					else
						return $set->display;
					break;
				case self::x²token :
					if (2 > strlen($set->value))
						throw new Exception(__CLASS__ . "->complode emptyToken not allowed");
					if (preg_match("/\s/", $set->value))
						throw new Exception(__CLASS__ . "->escape prepare-token must not have space");
					$this->prepare = true;
					$counter = $this->bind_count++;
					$this->bind->$counter = new stdClass();
					$this->bind->$counter->bind = "Param";
					$this->bind->$counter->key = $set->value;
					$this->bind->$counter->type = PDO::PARAM_STR;
					$this->bind->$counter->value = self::null_string;
					if (@$cfg->no_alias) {
						return x²sql::escape(x²sql::tokenizer . $set->value, "");
					}
					else
						return $set->display;
					break;
				case self::x²null:
				case self::x²bool :
				case self::x²number :
				case self::x²string :
				case self::x²key :
					if ($class === self::x²string && !strlen($set->value)
					) {
						return self::esc_string . self::esc_string;
					}
					if (@$cfg->escape) {
						return x²sql::escape($set->value, $cfg->escape)
										. (@$cfg->no_alias ? "" : " " . x²sql::escape($set->alias, self::esc_key) );
					} elseif (@$cfg->no_alias) {
						return (new $class($set->value,""))->display;
					} else {
						return $set->display;
					}
					break;
				case self::x²order:case self::x²operator:case self::x²math:
					return $set->display;
					break;
				case self::x²func:
					$str = array();
					foreach ($set->argus as $arg) {
						$str[] = $this->complode($arg);
					}
					return $set->name
									. self::char_bracket_open
									. implode(self::char_list_delimiter, $str)
									. self::char_bracket_close
									. (@$cfg->no_alias ? "" : " " . x²sql::escape($set->alias, self::esc_key) );
					break;
				case __CLASS__:
					if ($set->prepare) {
						$this->prepare = true;
						foreach ($set->bind as $key => $bind) {
							$this->bind_count+=1;
							$this->bind->{$this->bind_count + $set->bind_count} = $bind;
						}
					}
					return $set->command;
				default:
					if (!isset($set->type))
						throw new Exception("$class::property:type does not exist");
					//$this->stdClass2x²class
					switch (@$set->type) {
						case self::x²null:
						case self::x²bool :
						case self::x²number :
						case self::x²place :
						case self::x²token :
						case self::x²string :
						case self::x²key :
							$class = $set->type;
							return $this->complode(new $class($set->value, @$set->alias), $cfg);
							break;
						case self::x²func :
							return $this->complode(new x²func($set->name, @$set->argus, @$set->alias), $cfg);
							break;
						case __CLASS__:
							return $this->complode(new x²sql($set), $cfg);
							break;
						case self::x²order:
							return $this->complode(new x²order($set->name, @$set->direction), $cfg);
							break;
						case self::x²operator:
							return $this->complode(new x²operator($set->value), $cfg);
							break;
						case self::x²math:
							return $this->complode(new x²math($set->value), $cfg);
							break;
						default:
							$class = get_class($set);
							if (!method_exists($class, "__toString"))
								throw new Exception(__CLASS__ . "->implode unkown type");
							else {
								return $this->complode($set->__toString(), $cfg);
							}
							break;
					}
					///$this->stdClass2x²class
					break;
			}
		} elseif (is_bool($set)) {
			$set = $set ? "1" : "0";
			$class = @$cfg->cast ? $cfg->cast : "x²bool";
			return $this->complode(new $class($set), $cfg);
		} elseif (is_numeric($set)) {
			$class = @$cfg->cast ? $cfg->cast : "x²number";
			return $this->complode(new $class($set), $cfg);
		} elseif (is_string($set)) {

			if ($this->current_call == "where" || $this->current_call == "having")
				if (preg_match(self::regex_operators, $set) && (@$cfg->array_position & 1))
					return $set;
			if ($set == self::placerholder) {
				return $this->complode(new x²place($set), $cfg);
			} elseif (substr($set, 0, 1) == self::tokenizer) {
				return $this->complode(new x²token(substr($set, 1)), $cfg);
			} else {
				$class = @$cfg->cast ? $cfg->cast : "x²string";
				return $this->complode(new $class($set), $cfg);
			}
		} throw new Exception("you should never reach this point");
	}

	static public function escape($str, $esc = "", $operator = 0) {
		if (is_string($str) && strlen($str) == 0)
			return "";
		if ($str === self::null_string || $str === null) {
			return self::null_string;
		} elseif (is_bool($str))
			return $str ? $esc . "1" . $esc : $esc . "0" . $esc;
		elseif ($str === self::placerholder)
			return $str;
		elseif (is_numeric($str))
			return $esc . $str . $esc;
		elseif (preg_match(self::regex_operators, $str) && $operator)
			return trim($str);
		elseif (substr($str, 0, 1) != self::tokenizer) {

			$ndl = array("/\\r/", "/\\n/", "/\\t/");
			$rep = array("\\r", "\\n", "\\t");

			if (trim($esc)) {
				$ndl[] = "/" . $esc . "/";
				$rep[] = $esc === self::esc_key ? $esc . $esc : "\\" . $esc;
			}
			return $esc . preg_replace($ndl, $rep, $str) . $esc;
		} else {
			if (preg_match("/\s/", trim($str)))
				throw new Exception("tokenizer must have no space");
		}

		return $str;
	}

	public function select($set = "*") {
		$this->current_call = __FUNCTION__;
		if (!$this->command_type)
			$this->command_type = __FUNCTION__;
		if ($set === "" || $set === null || $set === "*") {
			$this->command.= $this->last_append = __FUNCTION__ . " *";
		} else {
			$cfg = new stdClass;
			$cfg->no_brackets = true;
			$cfg->cast = "x²key";
			$this->command.= $this->last_append = __FUNCTION__ . " " . $this->complode($set, $cfg);
		}
		return $this;
	}

	public function insert($set) {
		$this->current_call = __FUNCTION__;
		$this->command_type = __FUNCTION__;
		$cfg = new stdClass;
		$cfg->cast = "x²key";
		$cfg->allow = array(self::x²string, self::x²key, self::x²token, __CLASS__);
		$cfg->no_brackets = true;
		$this->command.= $this->last_append = __FUNCTION__ . " into " . $this->complode($set, $cfg);
		return $this;
	}

	public function from($set) {
		$this->current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		$cfg = new stdClass;
		$cfg->cast = "x²key";
		$cfg->allow = array(self::x²string, self::x²key, self::x²token, __CLASS__);
		$cfg->no_brackets = true;
		$this->command.= $this->last_append = " " . __FUNCTION__ . " " . $this->complode($set, $cfg);
		return $this;
	}

	public function update($set) {
		$this->current_call = __FUNCTION__;
		$this->command_type = __FUNCTION__;
		$cfg = new stdClass;
		$cfg->cast = "x²key";
		$cfg->allow = array(self::x²string, self::x²key, self::x²token, __CLASS__);
		$cfg->no_brackets = true;
		$this->command.= $this->last_append = __FUNCTION__ . " " . $this->complode($set, $cfg);
		return $this;
	}

	public function delete($set) {
		$this->current_call = __FUNCTION__;
		$this->command_type = __FUNCTION__;
		$cfg = new stdClass;
		$cfg->cast = "x²key";
		$cfg->allow = array(self::x²string, self::x²key, self::x²token, __CLASS__);
		$cfg->no_brackets = true;
		$this->command.= $this->last_append = __FUNCTION__ . " from " . $this->complode($set, $cfg);
		return $this;
	}

	public function where($set) {
		$this->current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (!is_array($set) && !is_object($set)) {
			$set = array($set);
		}
		$cfg = new stdClass;
		$cfg->delimiter = " ";
		$cfg->no_alias = true;
		$this->command.= $this->last_append = " " . __FUNCTION__ . " " . $this->complode($set, $cfg);
		return $this;
	}

	public function having($set) {
		$this->current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (!is_array($set) && !is_object($set)) {
			$set = array($set);
		}
		$cfg = new stdClass;
		$cfg->delimiter = " ";
		$cfg->no_alias = true;
		$this->command.= $this->last_append = " " . __FUNCTION__ . " " . $this->complode($set, $cfg);
		return $this;
	}

	public function group($set) {
		$this->current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (!is_array($set) && !is_object($set)) {
			$set = array($set);
		}
		$cfg = new stdClass;
		$cfg->no_alias = true;
		$cfg->no_brackets = true;
		$cfg->cast = self::x²key;
		$this->command.= $this->last_append = " " . __FUNCTION__ . " by " . $this->complode($set, $cfg);
		return $this;
	}

	public function order($set) {
		$this->current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (!is_array($set) && !is_object($set)) {
			$set = array($set);
		}
		$cfg = new stdClass;
		$cfg->no_alias = true;
		$cfg->no_brackets = true;
		$cfg->allow = array(self::x²key, self::x²order, self::x²string, self::x²number, self::x²token);
		$cfg->cast = self::x²order;
		$this->command.= $this->last_append = " " . __FUNCTION__ . " by " . $this->complode($set, $cfg);
		return $this;
	}

	public function limit($set) {
		$this->current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (is_a($set, "x²number")) {
			$set = $set->value;
		}
		if (is_string($set) && substr($set, 0, 1) == self::tokenizer || $set == self::placerholder) {
			$this->command.= $this->last_append =
							" " . __FUNCTION__ . " " . $this->complode($set);
			return $this;
		}
		if (is_numeric($set)) {
			$this->command.= $this->last_append =
							" " . __FUNCTION__ . " " . $this->complode(round($set));
			return $this;
		}
		throw new Exception(__CLASS__ . "->limit: $set  is not a number");
	}

	public function offset($set) {
		$this->current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (is_a($set, "x²number")) {
			$set = $set->value;
		}
		if (is_string($set) && substr($set, 0, 1) == self::tokenizer || $set == self::placerholder) {
			$this->command.= $this->last_append =
							" " . __FUNCTION__ . " " . $this->complode($set);
			return $this;
		}
		if (is_numeric($set)) {
			$this->command.= $this->last_append =
							" " . __FUNCTION__ . " " . $this->complode(round($set));
			return $this;
		}
		$set*=1;
		throw new Exception(__CLASS__ . "->offset: var is not a number");
	}

	public function columns($set) {
		$this->current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (!is_array($set)) {
			$set = array($set);
		}
		$cfg = new stdClass();
		$cfg->escape = self::esc_key;
		$cfg->allow = array(self::x²key, self::x²string, self::x²place, self::x²token);
		$cfg->no_alias = true;
		$this->command.= $this->last_append = $this->complode($set, $cfg);
		return $this;
	}

	public function values($set) {
		$this->current_call = __FUNCTION__;
		if (!is_array($set)) {
			$set = array($set);
		}
		$cfg = new stdClass();
		$cfg->no_alias = true;
		$this->command.= $this->last_append = " values" . $this->complode($set, $cfg);
		return $this;
	}

	public function set($set, $options = null) {
		$this->current_call = __FUNCTION__;
		if ($set === null)
			return $this;

		if ($this->flag) {
			$this->command_type = __FUNCTION__;
			$this->command = __FUNCTION__ . " ";
		} else {
			$this->command.=" " . __FUNCTION__ . " ";
		}

		if (!is_array($set) && !is_object($set))
			throw new Exception("set input must be iteratable array or object");

		$cfg = new stdClass;
		$cfg->no_alias = true;
		$tmp = array();

		if ($this->flag) {
			foreach ($set as $key => $val) {
				$tmp[$key] = preg_replace('/[^a-z0-9_@$]/i', '', $key);
				$tmp[$key].= "=";
				$tmp[$key].= "(" . $this->complode($val, $cfg) . ")";
			}
		} else {
			foreach ($set as $key => $val) {
				$tmp[$key] = self::escape($key, self::esc_key);
				$tmp[$key].= "=";
				$tmp[$key].= $this->complode($val, $cfg);
			}
		}


		$this->command.= $this->last_append = implode(self::char_list_delimiter, $tmp) . " ";
		return $this;
	}

	public function union($set) {
		$this->current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		$cfg = new stdClass();
		$cfg->delimiter = " union ";
		$cfg->no_alias = true;
		$cfg->no_brackets = true;
		$this->command.= $this->last_append = " union " . $this->complode($set, $cfg);
		return $this;
	}

	public function transaction($set) {
		if (!is_array($set))
			return $this;
		$this->command_type = __FUNCTION__;
		$this->command = array();
		foreach ($set as $key => $statement) {
			$x²sql = new x²sql($statement);
			if ($x²sql->prepare) {
				$this->prepare = true;
				$this->bind->$key = $x²sql->bind;
			}
			$this->command[] = $this->last_append = $x²sql->command . ";";
		}

		return $this;
	}

	public function fetch($fetch) {
		$this->current_call = __FUNCTION__;
		if ($fetch)
			$this->fetch = $fetch;
		return $this;
	}

	public function fetch_type($type) {
		$this->current_call = __FUNCTION__;
		if ($type)
			$this->fetch_type = $type;
		return $this;
	}

	public function alias($set,$cfg=null) {
		
		$this->current_call = __FUNCTION__;
		if ($set === null || $set==x²sql::null_string || $set ==="")
			return $this;
		
		$o =x²sql::char_bracket_open; 
		$c=x²sql::char_bracket_close; 

		$afg = new stdClass;
		$afg->cast=x²sql::x²key;
		$afg->no_brackets = true;
		$this->command= $this->last_append = $o.$this->command.$c.(@$cfg->no_alias?"":" ".$this->complode($set,$afg));

		return $this;
	}

	public function create($set) {
		$this->current_call = __FUNCTION__;
		$this->command_type = __FUNCTION__;
		if (in_array(strtoupper($set), [
								"DATABASE",
								"EVENT",
								"FUNCTION",
								"INDEX",
								"LOGFILE GROUP",
								"PROCEDURE",
								"FUNCTION",
								"SERVER",
								"TABLE",
								"TABLESPACE",
								"TRIGGER",
								"VIEW"]))
			;
		if (!preg_match("/;$set;/i", ";" . implode(";", $this->disallow_create) . ";")) {
			$this->command.= $this->last_append = " create  " . $set;
		}
		return $this;
	}

	public function options($set) {
		$this->current_call = __FUNCTION__;
		$this->command.= $this->last_append = ""; // not supported yet
		return $this;
	}

	public function plock(&$set) {
		$this->current_call = __FUNCTION__;
		$create_pl_block = x²plock::{$set->create}($set);
		foreach($create_pl_block->bind as $key => $obj){
			$this->bind->{$key} = $obj;
		}
		$this->command.= $this->last_append = " " . $create_pl_block->command;
		return $this;
	}

	public function name($set) {
		$this->current_call = __FUNCTION__;
		$cfg = new stdClass;
		$cfg->no_brackets = true;
		$cfg->no_alias = true;
		$cfg->cast = "x²key";
		$this->command.= $this->last_append = " " . $this->complode($set, $cfg);
		return $this;
	}

	public function comment($text) {
		$this->current_call = __FUNCTION__;
		$this->name = $text;
		return $this;
	}

	public function __name($__name) {
		$this->current_call = __FUNCTION__;
		$this->__name = $__name;
		return $this;
	}

}

class x²plock {

	public static function view(&$cfg) {
		//create :view :name :as (x²sql:select  :for);
		if (!isset($cfg->as))
			throw new Exception("x²plock::view has no create 'as' param");
		$as = $cfg->as;
		$as->type = x²sql::x²sql;
		$sql = new x²sql($as);$sql->command = "as  ".$sql->command;
		return $sql;
	}

}

class x²func {

	public $name;
	public $alias;
	public $argus;
	public $text;

	public function __construct($name, $argus = null, $alias = "") {
		if (preg_match("/\s|\n|\r|\t/", $name))
			throw new Exception(__CLASS__ . "->name must not have spaces");
		$this->name = $name;
		if (preg_match("/\s|\n|\r|\t/", $alias))
			throw new Exception(__CLASS__ . "->alias must not have spaces");
		$this->alias = $alias;

		if (is_bool($argus) || is_numeric($argus) || is_string($argus) || is_object($argus)) {
			$this->argus = array($argus);
		} else if ($argus === null)
			$this->argus = array();
		else
			$this->argus = $argus;
	}

}

class x²base {

	public $value;
	public $alias;
	public $display;
	public $escape = x²sql::esc_string;

	public function __construct($value, $alias = "") {
		$this->value = $value;
		$this->alias = $alias;
	}

}

class x²token extends x²base {

	public $escape = x²sql::esc_non;

	public function __construct($value, $alias = "") {
		if (preg_match("/\s/", $value))
			throw new Exception(__CLASS__ . "->value space is not allowed");
		$value = (substr($value, 0, 1) == x²sql::tokenizer) ? substr($value, 1) : $value;
		parent::__construct($value, $alias);
		$this->display = x²sql::tokenizer . x²sql::escape($value, x²sql::esc_non)
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
		;
	}

}

class x²string extends x²base {

	public function __construct($value, $alias = "") {
		parent::__construct($value, $alias);
		$this->display = x²sql::escape($value, x²sql::esc_string)
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
	}

}

class x²key extends x²base {

	public $escape = x²sql::esc_key;

	public function __construct($value, $alias = "") {

		parent::__construct($value, $alias);

		if (is_array($value)) {
			foreach ($value as $i => $_) {
				if (!(is_object($_) && $_->type == x²sql::x²operator && $_->value == "*"))
					$value[$i] = x²sql::escape($_, x²sql::esc_key);
				else
					$value[$i] = "*";
			}
			$value = implode(".", $value);
			$this->display = $value . (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
		}
		else if ($value == null) {
			$this->display = "";
		} else {

			$this->display = x²sql::escape($value, x²sql::esc_key)
							. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
		}

		if (preg_match("/\s/", $value))
			throw new Exception(__CLASS__ . "->value space is not allowed");
	}

}

class x²bool extends x²base {

	public $escape = x²sql::esc_non;

	public function __construct($value, $alias = "") {
		if (!is_bool($value) && !preg_match("/true|false|1|0/i", $value)) // localized ...
			throw new Exception(__CLASS__ . "->value is no boolean");
		parent::__construct($value, $alias);
		$this->display = ($value ? "1" : "0")
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
	}

}

class x²number extends x²base {

	public $escape = x²sql::esc_non;

	public function __construct($value, $alias = "") {
		if (!is_numeric($value))
			throw new Exception(__CLASS__ . "->value is no number");
		parent::__construct($value, $alias);
		$this->display = x²sql::escape($value, x²sql::esc_non)
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
		;
	}

}

class x²null extends x²base {

	public $escape = x²sql::esc_non;

	public function __construct($value = null, $alias = "") {
		if ($value !== null && $value !== x²sql::null_string)
			throw new Exception(__CLASS__ . "->value is no valid null");
		parent::__construct($value, $alias);
		$this->display = x²sql::null_string
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
	}

}

class x²place extends x²base {

	public $escape = x²sql::esc_non;

	public function __construct($value = null, $alias = "") {
		parent::__construct(x²sql::placerholder, $alias);
		$this->display = x²sql::placerholder
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
	}

}

class x²order extends x²base {

	public function __construct($value, $direction = "") {
		if ("asc" != strtolower($direction) && "desc" != strtolower($direction) && $direction !== "")
			throw new Exception(__CLASS__ . "->direction must be 'asc' 'desc' or emptyString");
		parent::__construct($value, $direction);
		$this->display = x²sql::escape($value, x²sql::esc_key)
						. (strlen($this->alias) ? " " . $this->alias : "");
	}

}

class x²operator extends x²base {

	public $value;

	public function __construct($operator) {
		if (!preg_match(x²sql::regex_operators, $operator))
			throw new Exception(__CLASS__ . " no valid operator");
		$this->value = $operator;
		$this->display = $operator;
	}

}

class x²math extends x²base {

	const regex_math = "/(:=|\|\||OR|XOR|&&|AND|NOT|BETWEEN|CASE|WHEN|THEN|ELSE|=|<=>|>=|<=|<|<>|>|!=|IS|LIKE|REGEXP|IN|\||&|<<|>>|-|\+|\*|\/|DIV|%|MOD|^|~|!|BINARY|COLLATE)/i";

	public $value;

	public function __construct($math) {
		if (preg_match("/[^\s0-9\.\*+-\/=<>!&%~\(\)]/", $math))
			throw new Exception(__CLASS__ . " no valid math expression");
		$this->value = str_replace(array(" ", "\n", "\r", "\t"), "", $math);
		$this->display = $math;
	}

}

?>

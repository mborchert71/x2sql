<?php

/**
 * x²sql
 *
 * An open source SQL-generator-class.
 * Inspired by the database-driver in Code-igniter http://ellislab.com/codeigniter.
 *   if (get_magic_quotes_gpc()) {        $value = stripslashes($value);    }
 * 
 * x²func redo ... text to display .. funcname to x²key alias to x²key
 * 2 ways . 1.standalone strictmode . every argument explicit or string escaped if not number
 *          2.relaxed mode lazy ... oder in  den x²s die ganzen kreuzauflösungen schon vornehmen ...
 *  dürfte auch complode um einiges schlanker machen ...  oh man seit ? monaten ... langsam hängt mir das wider trotz pausen zum hals raus ...
 *  ja ich weiss immer geschoben .. func war zuerst und dann x²base und nicht angepasst ... weil noch so viel zu tun war, was wichtiger war...
 *  immer wieder die selben fallen ... oder hindernisse...
 * 
 * @package		x²sql
 * @author		mborchert
 * @copyright           Copyright (c) 2013.
 * @license		http://creativecommons.org/licenses/by/3.0/deed.de
 * @link		http://get-resource.net/app/php/x²sql
 * @since		Version 1.0
 * @todo: join
 * @todo: support special settings : distinct, etc.
 * @todo: config_setting_options for complode : delimiter,no_brackets,no_alias,cast,escape,allow,array_position
 */
class x²sql {

	const x²sql = "x²sql";
	const x²null = "x²z";
	const x²bool = "x²b";
	const x²number = "x²n";
	const x²string = "x²s";
	const x²func = "x²f";
	const x²token = "x²t";
	const x²place = "x²p";
	const x²key = "x²k";
	const x²order = "x²o";
	const x²operator = "x²op";
	const x²math = "x²m";
	const char_list_delimiter = ",";
	const char_bracket_open = "(";
	const char_bracket_close = ")";
	const tokenizer = ":";
	const placeholder = "?";
	const esc_string = "'";
	const esc_key = "`";
	const esc_non = "";
	const esc_num = "";
	const null_string = "null";

	public $tokenizer = ":";
	public $placeholder = "?";
	public $esc_string = "'";
	public $esc_key = "`";
	public $esc_non = "";
	public $esc_num = "";
	public $null_string = "null";
	public $x²sql = "x²sql";
	public $x²null = "x²null";
	public $x²bool = "x²bool";
	public $x²number = "x²number";
	public $x²string = "x²string";
	public $x²func = "x²func";
	public $x²token = "x²token";
	public $x²place = "x²place";
	public $x²key = "x²key";
	public $x²order = "x²order";
	public $x²operator = "x²operator";
	public $x²math = "x²math";
	public $char_list_delimiter = ",";
	public $char_bracket_open = "(";
	public $char_bracket_close = ")";
	private $flag;
	public $__name;
	public $comment;
	public $command;
	public $command_type;
	public $fetch = "fetchAll";
	public $fetch_type = PDO::FETCH_NUM;
	public $init_data;
	public $last_append;
	public $disallow_create = [];
	static private $current_call;
	static public $prepare = false;
	static public $bind;
	static public $bind_count = 0;

	const token_function_list = ",command,select,from,union,where,group,having,order,limit,offset,fetch,fetch_type,alias,insert,columns,values,update,delete,where,transaction,set,__name,comment,create,options,name,plock,";

	public function __toString() {
		return (is_array($this->command)) ? implode("\n", $this->command) : $this->command;
	}

	public function reset() {
		self::$bind = new stdClass();
		self::$bind_count = 0;
		self::$prepare = false;
		$this->init_data = null;
		$this->command = "";
		$this->command_type = null;
		$this->last_append = "";
		$this->fetch = "fetchAll";
		$this->fetch_type = PDO::FETCH_NUM;
		$this->comment = "";
		$this->__name = "";
	}

	public function get_cfg_data(&$cfg) {
		if (is_string($cfg) && preg_match("/^[\{\(]{1,999}/", $cfg)) {
			$jcfg = json_decode($cfg);
			if (!is_array($jcfg) && !is_object($jcfg)) {
				throw new Exception("invalid Json");
			}
			return $jcfg;
		}
		return $cfg;
	}

	public function Sql(&$cfg) {

		$this->init_data = $cfg;
		$cfg = $this->get_cfg_data($cfg);

		if (isset($cfg->command)) {
			if (is_string($cfg->command)) {
				$_ = explode(" ", $cfg->command);
				$this->command_type = array_shift($_);
				unset($_);
			} else {
				$this->command_type = $cfg->command[0];
				foreach ($cfg->command as &$c) {
					if (is_object($c) || is_array($c))
						$c = self::complode($c);
				}
			}
			$this->command = implode("\n", $cfg->command);
			return $this;
		}
		if (isset($cfg->select))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->select($cfg->select)
											->from(@$cfg->from)
											->union(@$cfg->union)
											->where(@$cfg->where)
											->group(@$cfg->group)
											->having(@$cfg->having)
											->order(@$cfg->order)
											->limit(@$cfg->limit)
											->offset(@$cfg->offset)
											->fetch(@$cfg->fetch)
											->fetch_type(@$cfg->fetch_type)
											->alias(@$cfg->alias, $cfg);
		if (isset($cfg->insert))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->insert($cfg->insert)
											->columns($cfg->columns)
											->values($cfg->values);
		if (isset($cfg->update))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->update($cfg->update)
											->set($cfg->set)
											->where($cfg->where);
		if (isset($cfg->delete))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->delete($cfg->delete)
											->where($cfg->where);
		if (isset($cfg->transaction))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->transaction($cfg->transaction);
		if (isset($cfg->set))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->flag("command")
											->set($cfg->set)
											->unflag();
		if (isset($cfg->create))
			return $this->__name(@$cfg->__name)
											->comment(@$cfg->comment)
											->create($cfg->create)
											->options(@$cfg->options)
											->name($cfg->name)
											->plock($cfg);
	}

	public function __construct($cfg = null) {
		self::$bind = new stdClass;

		if ($cfg) {
			return $this->Sql($cfg);
		}
	}

	public function flag($hint) {
		$this->flag = $hint;
		return $this;
	}

	public function unflag() {
		$this->flag = null;
		return $this;
	}

	static public function query($cfg = null) {
		return new x²sql($cfg);
	}

	static public function complode($set, $cfg = null) {
		if (!$cfg)
			$cfg = new stdClass;
		if ($set === null) {
			return self::complode(new x²null(), $cfg);
		}
		if (is_array($set)) {
			$delimiter = @$cfg->delimiter ? $cfg->delimiter : self::char_list_delimiter;
			$_ = [];
			foreach ($set as $key => $subset) {
				$cfg->array_position = $key;
				$_[] = self::complode($subset, $cfg);
			}
			return ((@$cfg->no_brackets) ? "" : self::char_bracket_open)
							. implode($delimiter, $_)
							. ((@$cfg->no_brackets) ? "" : self::char_bracket_close);
		} elseif (is_object($set)) {
			$class = get_class($set);
			if (isset($cfg->allow) && !in_array($class, $cfg->allow) && !method_exists($class, "__toString")) {
				if ($class != "stdClass")
					throw new Exception("$class is not allowed");
			}
			switch ($class) {
				case self::x²place: case "x²place" :
					self::$prepare = true;
					$counter = self::$bind_count++;
					self::$bind->$counter = new stdClass();
					self::$bind->$counter->bind = "Param";
					self::$bind->$counter->key = self::placeholder;
					self::$bind->$counter->type = PDO::PARAM_STR;
					self::$bind->$counter->value = self::null_string;
					if (@$cfg->no_alias) {
						return self::escape($set->value, "");
					}
					else
						return $set->display;
					break;
				case self::x²token: case "x²token" :
					if (2 > strlen($set->value))
						throw new Exception(__CLASS__ . "->complode emptyToken not allowed");
					if (preg_match("/\s/", $set->value))
						throw new Exception(__CLASS__ . "->escape prepare-token must not have space");
					self::$prepare = true;
					$counter = self::$bind_count++;
					self::$bind->$counter = new stdClass();
					self::$bind->$counter->bind = "Param";
					self::$bind->$counter->key = $set->value;
					self::$bind->$counter->type = PDO::PARAM_STR;
					self::$bind->$counter->value = self::null_string;
					if (@$cfg->no_alias) {
						return self::escape(self::tokenizer . $set->value, "");
					}
					else
						return $set->display;
					break;
				case self::x²null: case "x²null":
				case self::x²bool : case "x²bool":
				case self::x²number : case "x²number":
				case self::x²string : case "x²string":
				case self::x²key : case "x²key":
					if ($class === self::x²string && !strlen($set->value)
					) {
						return self::esc_string . self::esc_string;
					}
					if (@$cfg->escape && $cfg->escape != $set->escape) {
						return self::escape($set->value, $cfg->escape)
										. (@$cfg->no_alias ? "" : " " . self::escape($set->alias, self::esc_key) );
					} elseif (@$cfg->no_alias) {
						return (new $class($set->value, ""))->display;
					} else {
						return $set->display;
					}
					break;
				case self::x²order: case "x²order":
				case self::x²operator: case "x²operator":
					return $set->display;
					break;
				case self::x²math: case "x²math":
				case self::x²func: case "x²func":
					return @$cfg->no_alias ? $set->display_no_alias : $set->display;
					break;
				case __CLASS__:
					if (@$set->prepare) {
						self::$prepare = true;
						foreach ($set->bind as $key => $bind) {
							self::$bind_count+=1;
							self::$bind->{self::$bind_count + $set->bind_count} = $bind;
						}
					}
					return $set->command;
				default:
					if (!isset($set->type))
						throw new Exception("$class::property:type does not exist");
					//$this->stdClass2x²class
					switch (@$set->type) {
						case self::x²null: case "x²null":
						case self::x²bool : case "x²bool":
						case self::x²number : case "x²number":
						case self::x²place : case "x²place" :
						case self::x²token : case "x²token" :
						case self::x²string : case "x²string":
						case self::x²key : case "x²key":
							$class = $set->type;
							return self::complode(new $class($set->value, @$set->alias), $cfg);
							break;
						case self::x²func : case "x²func":
							return self::complode(new x²func($set->value, @$set->alias, @$set->argus), $cfg);
							break;
						case __CLASS__:
							return self::complode(new x²sql($set), $cfg);
							break;
						case self::x²order: case "x²order":
							return self::complode(new x²order($set->name, @$set->direction), $cfg);
							break;
						case self::x²operator: case "x²operator":
							return self::complode(new x²operator($set->value), $cfg);
							break;
						case self::x²math: case "x²math":
							return self::complode(new x²math($set->value), $cfg);
							break;
						default:
							$class = get_class($set);
							if (!method_exists($class, "__toString"))
								throw new Exception(__CLASS__ . "->implode unkown type");
							else {
								return self::complode($set->__toString(), $cfg);
							}
							break;
					}
					///$this->stdClass2x²class
					break;
			}
		} elseif (is_bool($set)) {
			$set = $set ? "1" : "0";
			$class = @$cfg->cast ? $cfg->cast : "x²bool";
			return self::complode(new $class($set), $cfg);
		} elseif (is_numeric($set)) {
			$class = @$cfg->cast ? $cfg->cast : "x²number";
			return self::complode(new $class($set), $cfg);
		} elseif (is_string($set)) {
			if (self::$current_call == "select" && $set == "*")
				return "*";

			if (self::$current_call == "where" || self::$current_call == "having")
				if (preg_match(x²operator::regex, $set) && (@$cfg->array_position & 1))
					return $set;
			if ($set == self::placeholder) {
				return self::complode(new x²place($set), $cfg);
			} elseif (substr($set, 0, 1) == self::tokenizer) {
				return self::complode(new x²token(substr($set, 1)), $cfg);
			} else {
				$class = @$cfg->cast ? $cfg->cast : "x²string";
				return self::complode(new $class($set), $cfg);
			}
		} throw new Exception("you should never reach this point");
	}

	static public function escape($str, $esc = "", $operator = 0) {
		if (is_string($str) && strlen($str) == 0)
			return "";
		if ($str === self::null_string || $str === null) {
			return self::null_string;
		} elseif (is_bool($str))
			return $str ? $esc . "1" . $esc : $esc . "0" . $esc;
		elseif ($str === self::placeholder)
			return $str;
		elseif (is_numeric($str))
			return $esc . $str . $esc;
		elseif (preg_match(x²operator::regex, $str) && $operator)
			return trim($str);
		elseif (substr($str, 0, 1) != self::tokenizer) {

			$ndl = array("/\\r/", "/\\n/", "/\\t/");
			$rep = array("\\r", "\\n", "\\t");

			if (trim($esc)) {
				$ndl[] = "/" . $esc . "/";
				$rep[] = $esc === self::esc_key ? $esc . $esc : "\\" . $esc;
			}
			return $esc . preg_replace($ndl, $rep, $str) . $esc;
		} else {
			if (preg_match("/\s/", trim($str)))
				throw new Exception("tokenizer must have no space");
		}

		return $str;
	}

	public function select($set = "*") {
		self::$current_call = __FUNCTION__;

		if (!$this->command_type)
			$this->command_type = __FUNCTION__;
		if ($set === "" || $set === null || $set === "*") {
			$this->command.= $this->last_append = __FUNCTION__ . " *";
		} else {
			$cfg = new stdClass;
			$cfg->no_brackets = true;
			$cfg->cast = "x²key";
			$this->command.= $this->last_append = __FUNCTION__ . " " . self::complode($set, $cfg);
		}
		return $this;
	}

	public function insert($set) {
		self::$current_call = __FUNCTION__;
		$this->command_type = __FUNCTION__;
		$cfg = new stdClass;
		$cfg->cast = "x²key";
		$cfg->allow = array(self::x²string, self::x²key, self::x²token, __CLASS__);
		$cfg->no_brackets = true;
		$this->command.= $this->last_append = __FUNCTION__ . " into " . self::complode($set, $cfg);
		return $this;
	}

	public function from($set) {
		self::$current_call = __FUNCTION__;
		if ($set === null || $set === "")
			return $this;
		$cfg = new stdClass;
		$cfg->cast = "x²key";
		$cfg->allow = array(self::x²string, self::x²key, self::x²token, __CLASS__);
		$cfg->no_brackets = true;
		$from = self::complode($set, $cfg);
		if ($from == "" || $from == null)
			throw new exception("could not evaluate from " . print_r($from, true));
		$this->command.= $this->last_append = " " . __FUNCTION__ . " " . $from;
		return $this;
	}

	public function update($set) {
		self::$current_call = __FUNCTION__;
		$this->command_type = __FUNCTION__;
		$cfg = new stdClass;
		$cfg->cast = "x²key";
		$cfg->allow = array(self::x²string, self::x²key, self::x²token, __CLASS__);
		$cfg->no_brackets = true;
		$this->command.= $this->last_append = __FUNCTION__ . " " . self::complode($set, $cfg);
		return $this;
	}

	public function delete($set) {
		self::$current_call = __FUNCTION__;
		$this->command_type = __FUNCTION__;
		$cfg = new stdClass;
		$cfg->cast = "x²key";
		$cfg->allow = array(self::x²string, self::x²key, self::x²token, __CLASS__);
		$cfg->no_brackets = true;
		$this->command.= $this->last_append = __FUNCTION__ . " from " . self::complode($set, $cfg);
		return $this;
	}

	public function where($set, $dropword = false) {
		self::$current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (!is_array($set) && !is_object($set)) {
			$set = array($set);
		}
		$cfg = new stdClass;
		$cfg->delimiter = " ";
		$cfg->no_alias = true;
		$this->command.= $this->last_append = " " . ($dropword ? "" : __FUNCTION__) . " " . self::complode($set, $cfg);
		return $this;
	}

	public function having($set) {
		self::$current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (!is_array($set) && !is_object($set)) {
			$set = array($set);
		}
		$cfg = new stdClass;
		$cfg->delimiter = " ";
		$cfg->no_alias = true;
		$this->command.= $this->last_append = " " . __FUNCTION__ . " " . self::complode($set, $cfg);
		return $this;
	}

	public function group($set) {
		self::$current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (!is_array($set) && !is_object($set)) {
			$set = array($set);
		}
		$cfg = new stdClass;
		$cfg->no_alias = true;
		$cfg->no_brackets = true;
		$cfg->cast = self::x²key;
		$this->command.= $this->last_append = " " . __FUNCTION__ . " by " . self::complode($set, $cfg);
		return $this;
	}

	public function order($set) {
		self::$current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (!is_array($set) && !is_object($set)) {
			$set = array($set);
		}
		$cfg = new stdClass;
		$cfg->no_alias = true;
		$cfg->no_brackets = true;
		$cfg->allow = array(self::x²key, self::x²order, self::x²string, self::x²number, self::x²token);
		$cfg->cast = self::x²order;
		$this->command.= $this->last_append = " " . __FUNCTION__ . " by " . self::complode($set, $cfg);
		return $this;
	}

	public function limit($set) {
		self::$current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (is_a($set, "x²number")) {
			$set = $set->value;
		}
		if (is_string($set) && substr($set, 0, 1) == self::tokenizer || $set == self::placeholder) {
			$this->command.= $this->last_append =
							" " . __FUNCTION__ . " " . self::complode($set);
			return $this;
		}
		if (is_numeric($set)) {
			$this->command.= $this->last_append =
							" " . __FUNCTION__ . " " . self::complode(round($set));
			return $this;
		}
		throw new Exception(__CLASS__ . "->limit: $set  is not a number");
	}

	public function offset($set) {
		self::$current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (is_a($set, "x²number")) {
			$set = $set->value;
		}
		if (is_string($set) && substr($set, 0, 1) == self::tokenizer || $set == self::placeholder) {
			$this->command.= $this->last_append =
							" " . __FUNCTION__ . " " . self::complode($set);
			return $this;
		}
		if (is_numeric($set)) {
			$this->command.= $this->last_append =
							" " . __FUNCTION__ . " " . self::complode(round($set));
			return $this;
		}
		$set*=1;
		throw new Exception(__CLASS__ . "->offset: var is not a number");
	}

	public function columns($set) {
		self::$current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		if (!is_array($set)) {
			$set = array($set);
		}
		$cfg = new stdClass();
		$cfg->escape = self::esc_key;
		$cfg->allow = array(self::x²key, self::x²string, self::x²place, self::x²token);
		$cfg->no_alias = true;
		$this->command.= $this->last_append = self::complode($set, $cfg);
		return $this;
	}

	public function values($set) {
		self::$current_call = __FUNCTION__;
		if (!is_array($set)) {
			$set = array($set);
		}
		$cfg = new stdClass();
		$cfg->no_alias = true;
		$this->command.= $this->last_append = " values" . self::complode($set, $cfg);
		return $this;
	}

	public function set($set, $options = null) {
		self::$current_call = __FUNCTION__;
		if ($set === null)
			return $this;

		if ($this->flag) {
			$this->command_type = __FUNCTION__;
			$this->command = __FUNCTION__ . " ";
		} else {
			$this->command.=" " . __FUNCTION__ . " ";
		}

		if (!is_array($set) && !is_object($set))
			throw new Exception("set input must be iteratable array or object");

		$cfg = new stdClass;
		$cfg->no_alias = true;
		$tmp = array();

		if ($this->flag) {
			foreach ($set as $key => $val) {
				$tmp[$key] = preg_replace('/[^a-z0-9_@$]/i', '', $key);
				$tmp[$key].= "=";
				$tmp[$key].= "(" . self::complode($val, $cfg) . ")";
			}
		} else {
			foreach ($set as $key => $val) {
				$tmp[$key] = self::escape($key, self::esc_key);
				$tmp[$key].= "=";
				$tmp[$key].= self::complode($val, $cfg);
			}
		}


		$this->command.= $this->last_append = implode(self::char_list_delimiter, $tmp) . " ";
		return $this;
	}

	public function union($set) {
		self::$current_call = __FUNCTION__;
		if ($set === null)
			return $this;
		$cfg = new stdClass();
		$cfg->delimiter = " union ";
		$cfg->no_alias = true;
		$cfg->no_brackets = true;
		$this->command.= $this->last_append = " union " . self::complode($set, $cfg);
		return $this;
	}

	public function transaction($set) {
		if (!is_array($set))
			return $this;
		$this->command_type = __FUNCTION__;
		$this->command = array();
		foreach ($set as $key => $statement) {
			$x²sql = new x²sql($statement);
			if (self::$prepare) {
				self::$prepare = true;
				self::$bind->$key = $x²sql::$bind;
			}
			$this->command[] = $this->last_append = $x²sql->command . ";";
		}

		return $this;
	}

	public function fetch($fetch) {
		self::$current_call = __FUNCTION__;
		if ($fetch)
			$this->fetch = $fetch;
		return $this;
	}

	public function fetch_type($type) {
		self::$current_call = __FUNCTION__;
		if ($type)
			$this->fetch_type = $type;
		return $this;
	}

	public function alias($set, $cfg = null) {

		self::$current_call = __FUNCTION__;
		if ($set === null || $set == self::null_string || $set === "")
			return $this;

		$o = self::char_bracket_open;
		$c = self::char_bracket_close;

		$afg = new stdClass;
		$afg->cast = self::x²key;
		$afg->no_brackets = true;
		$this->command = $this->last_append = $o . $this->command . $c . (@$cfg->no_alias ? "" : " " . self::complode($set, $afg));

		return $this;
	}

	public function create($set) {
		self::$current_call = __FUNCTION__;
		$this->command_type = __FUNCTION__;
		if (in_array(strtoupper($set), [
								"DATABASE",
								"EVENT",
								"FUNCTION",
								"INDEX",
								"LOGFILE GROUP",
								"PROCEDURE",
								"FUNCTION",
								"SERVER",
								"TABLE",
								"TABLESPACE",
								"TRIGGER",
								"VIEW"]))
			;
		if (!preg_match("/;$set;/i", ";" . implode(";", $this->disallow_create) . ";")) {
			$this->command.= $this->last_append = " create  " . $set;
		}
		return $this;
	}

	public function options($set) {
		self::$current_call = __FUNCTION__;
		$this->command.= $this->last_append = ""; // not supported yet
		return $this;
	}

	public function plock(&$set) {
		self::$current_call = __FUNCTION__;
		$create_pl_block = x²plock::{$set->create}($set);
		foreach ($create_pl_block->bind as $key => $obj) {
			self::$bind->{$key} = $obj;
		}
		$this->command.= $this->last_append = " " . $create_pl_block->command;
		return $this;
	}

	public function name($set) {
		self::$current_call = __FUNCTION__;
		$cfg = new stdClass;
		$cfg->no_brackets = true;
		$cfg->no_alias = true;
		$cfg->cast = "x²key";
		$this->command.= $this->last_append = " " . self::complode($set, $cfg);
		return $this;
	}

	public function comment($text) {
		self::$current_call = __FUNCTION__;
		$this->name = $text;
		return $this;
	}

	public function __name($__name) {
		self::$current_call = __FUNCTION__;
		$this->__name = $__name;
		return $this;
	}

}

class x²plock {

	public static function view(&$cfg) {
		//create :view :name :as (self:select  :from);
		if (!isset($cfg->as))
			throw new Exception("x²plock::view has no create 'as' param");
		$as = $cfg->as;
		$as->type = self::x²sql;
		$sql = new x²sql($as);
		$sql->command = "as  " . $sql->command;
		return $sql;
	}

}

class x²funct {

	public $name;
	public $alias;
	public $argus;
	public $text;

	public function __construct($name, $argus = null, $alias = "") {
		if (preg_match("/\s|\n|\r|\t/", $name))
			throw new Exception(__CLASS__ . "->name must not have spaces");
		$this->name = $name;
		if (preg_match("/\s|\n|\r|\t/", $alias))
			throw new Exception(__CLASS__ . "->alias must not have spaces");
		$this->alias = $alias;

		if (is_bool($argus) || is_numeric($argus) || is_string($argus) || is_object($argus)) {
			$this->argus = array($argus);
		} else if ($argus === null)
			$this->argus = array();
		else
			$this->argus = $argus;
	}

}

class x²base {

	public $value;
	public $alias;
	public $display;
	public $escape = x²sql::esc_string;

	public function __construct($value, $alias = "") {
		$this->value = $value;
		$this->alias = $alias;
	}

	public function __toString() {
		return $this->display;
	}

}

class x²func extends x²base { //x²f

	public $argus;

	public function __construct($value, $alias = "", $argus = "") {

		if (preg_match("/\s|\n|\r|\t/", $value))
			throw new Exception(__CLASS__ . "->name must not have spaces");
		$this->value = $value;
		if (preg_match("/\s|\n|\r|\t/", $alias))
			throw new Exception(__CLASS__ . "->alias must not have spaces");
		$this->alias = $alias;

		if (!is_array($argus)) {
			$this->argus = array($argus);
		} else {
			$this->argus = $argus;
		}

		$this->argus = x²sql::complode($this->argus);

		if ($this->argus === null)
			$this->argus = "";

		$this->alias = $alias ? " " . (new x²key($alias)) : "";
		$this->display_no_alias = $value . $this->argus;
		$this->display = $value . $this->argus . $this->alias;
	}

}

class x²token extends x²base { //x²t

	public $escape = x²sql::esc_non;

	public function __construct($value, $alias = "") {
		if (preg_match("/\s/", $value))
			throw new Exception(__CLASS__ . "->value space is not allowed");
		$value = (substr($value, 0, 1) == x²sql::tokenizer) ? substr($value, 1) : $value;
		parent::__construct($value, $alias);
		$this->display = x²sql::tokenizer . x²sql::escape($value, x²sql::esc_non)
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
		;
	}

}

class x²string extends x²base { //x²s

	public function __construct($value, $alias = "") {
		parent::__construct($value, $alias);
		$this->display = x²sql::escape($value, x²sql::esc_string)
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
	}

}

class x²key extends x²base { //x²k

	public $escape = x²sql::esc_key;

	public function __construct($value, $alias = "") {

		parent::__construct($value, $alias);
		$display = [];
		if (is_array($value)) {
			foreach ($value as $i => &$_) {
				if ($_ != "*") {
					if (preg_match("/\s/", $_))
						throw new Exception(__CLASS__ . "->value space is not allowed");
					$display[] = x²sql::escape($_, x²sql::esc_key);
				}
				else
					$display[] = "*";
			}
			$this->display = implode(".", $display) . (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
		}
		else if ($value == null) {
			$this->display = "";
		} else {
			if (preg_match("/\s/", $value))
				throw new Exception(__CLASS__ . "->value space is not allowed");

			$this->display = x²sql::escape($value, x²sql::esc_key)
							. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
		}
	}

}

class x²bool extends x²base { //x²b

	public $escape = x²sql::esc_non;

	public function __construct($value, $alias = "") {
		if (!is_bool($value) && !preg_match("/true|false|1|0/i", $value)) // localized ...
			throw new Exception(__CLASS__ . "->value is no boolean");
		parent::__construct($value, $alias);
		$this->display = ($value ? "1" : "0")
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
	}

}

class x²number extends x²base { //x²n

	public $escape = x²sql::esc_non;

	public function __construct($value, $alias = "") {
		if (!is_numeric($value))
			throw new Exception(__CLASS__ . "->value is no number");
		parent::__construct($value, $alias);
		$this->display = x²sql::escape($value, x²sql::esc_non)
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
		;
	}

}

class x²null extends x²base { //x²z

	public $escape = x²sql::esc_non;

	public function __construct($value = null, $alias = "") {
		if ($value !== null && $value !== x²sql::null_string)
			throw new Exception(__CLASS__ . "->value is no valid null");
		parent::__construct($value, $alias);
		$this->display = x²sql::null_string
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
	}

}

class x²place extends x²base { //x²p

	public $escape = x²sql::esc_non;

	public function __construct($value = null, $alias = "") {
		parent::__construct(x²sql::placeholder, $alias);
		$this->display = x²sql::placeholder
						. (strlen($this->alias) ? " " . x²sql::escape($this->alias, x²sql::esc_key) : "");
	}

}

class x²order extends x²base { //x²s

	public function __construct($value, $direction = "") {
		parent::__construct($value, $direction);
		if ("asc" != strtolower($direction) && "desc" != strtolower($direction) && $direction !== "")
			throw new Exception(__CLASS__ . "->direction must be 'asc' 'desc' or emptyString");
		parent::__construct($value, $direction);
		if (is_a($value, "x²key")) {
			$this->value = $value->value;
		}
		$this->display = x²sql::escape($this->value, x²sql::esc_key)
						. (strlen($direction) ? " " . $direction : "");
	}

}

class x²operator extends x²base { //x²o

	const regex = "/^(:=|\|\||OR|XOR|&&|AND|NOT|BETWEEN|CASE|WHEN|THEN|ELSE|=|<=>|>=|<=|<|<>|>|!=|IS|LIKE|REGEXP|IN|\||&|<<|>>|-|\+|\*|\/|DIV|%|MOD|^|~|!|BINARY|COLLATE)$/i";

	public function __construct($operator) {

		parent::__construct($operator);

		if (!preg_match(self::regex, $operator))
			throw new Exception(__CLASS__ . " no valid operator");

		$this->escape = "";
		$this->display = $operator;
	}

}

class x²math extends x²base { //x²m

	const regex_math = "/(:=|\|\||OR|XOR|&&|AND|NOT|BETWEEN|CASE|WHEN|THEN|ELSE|=|<=>|>=|<=|<|<>|>|!=|IS|LIKE|REGEXP|IN|\||&|<<|>>|-|\+|\*|\/|DIV|%|MOD|^|~|!|BINARY|COLLATE)/i";

	public $value;

	public function __construct($math) {
		parent::__construct($math);

		$this->display = $this->prepro($math);
	}

	function prepro(&$m) {

		if (is_array($m)) {
			foreach ($m as $k => $_)
				$m[$k] = $this->prepro($_);
			return "(" . implode("", $m) . ")";
		} else if (is_a($m, "x²key"))
			return $m->display; //|| is_a($m,"x²func")todo
		else if (!is_object($m) && preg_match("/[^\s0-9\.\*+-\/=<>!&%~\(\)]/", $m))
			throw new Exception(__CLASS__ . "$m no valid math expression");
		if (!trim($m))
			return "+";
		return $m;
	}

}

class_alias("x²null", "x²z");
class_alias("x²bool", "x²b");
class_alias("x²number", "x²n");
class_alias("x²string", "x²s");
class_alias("x²func", "x²f");
class_alias("x²token", "x²t");
class_alias("x²place", "x²p");
class_alias("x²key", "x²k");
class_alias("x²order", "x²o");
class_alias("x²operator", "x²op");
class_alias("x²math", "x²m");
?>
